#include "qtpulseaudiocontextprivate.h"

#include <qtpulseaudio/qtpulseaudiocard.h>

QtPulseAudioConnectionPrivate::~QtPulseAudioConnectionPrivate()
{
    cardsByIndex.clear();
    cardsByName.clear();

    qDeleteAll(cards);
}

void QtPulseAudioConnectionPrivate::onCardsInfoList(pa_context* context, const pa_card_info* cardInfo, int eol, void* userData)
{
    qDebug();

    if (!eol)
    {
        QtPulseAudioConnectionPrivate* d = reinterpret_cast< QtPulseAudioConnectionPrivate* >(userData);

        QtPulseAudioCard* card = new QtPulseAudioCard(d->pulseAudioData, cardInfo);

        d->cards.insert(card);
        d->cardsByIndex.insert(card->index(), card);
        d->cardsByIndex.insert(card->name(), card);
    }
}

void QtPulseAudioConnectionPrivate::onContextNotify(pa_context* context, void* userData)
{
    Q_UNUSED(context);

    QtPulseAudioConnectionPrivate* d = reinterpret_cast< QtPulseAudioConnectionPrivate* >(userData);
    QtPulseAudioConnection* q = d->q;

    static QHash< pa_context_state_t, QtPulseAudio::ConnectionState > states;

    if (states.isEmpty())
    {
        states.insert(PA_CONTEXT_UNCONNECTED, QtPulseAudio::Unconnected);
        states.insert(PA_CONTEXT_CONNECTING, QtPulseAudio::Connecting);
        states.insert(PA_CONTEXT_AUTHORIZING, QtPulseAudio::Authorizing);
        states.insert(PA_CONTEXT_SETTING_NAME, QtPulseAudio::SettingName);
        states.insert(PA_CONTEXT_READY, QtPulseAudio::Ready);
        states.insert(PA_CONTEXT_FAILED, QtPulseAudio::Failed);
        states.insert(PA_CONTEXT_TERMINATED, QtPulseAudio::Terminated);
    }

    d->state = states.value(pa_context_get_state(context), QtPulseAudio::Unknown);

    emit q->stateChanged(d->state);
}
